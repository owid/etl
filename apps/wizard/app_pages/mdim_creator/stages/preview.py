"""Stage 4: Preview & Generate.

This stage shows:
- Summary statistics
- Preview of generated configuration
- Common view configuration options
- File generation and DAG integration
"""

from typing import Any

import streamlit as st
from rapidfuzz import fuzz

from apps.wizard.etl_steps.utils import dag_files, dag_not_add_option
from etl.dag_helpers import write_to_dag_file
from etl.files import ruamel_dump
from etl.paths import DAG_DIR, STEP_DIR

# Chart types available for views
CHART_TYPES = [
    "LineChart",
    "SlopeChart",
    "DiscreteBar",
    "StackedBar",
    "StackedArea",
    "ScatterPlot",
    "Marimekko",
]


def extract_dimensions_from_mapping(mapping: list[dict[str, Any]]) -> dict[str, list[str]]:
    """Extract dimensions and their unique values from the mapping."""
    dimensions: dict[str, set[str]] = {}

    # Get all columns except base columns
    base_cols = {"column", "indicator_name", "include"}

    for row in mapping:
        if not row.get("include", True):
            continue

        for key, value in row.items():
            if key in base_cols:
                continue
            if value and value not in ("", "(custom)"):
                if key not in dimensions:
                    dimensions[key] = set()
                dimensions[key].add(value)

    return {k: sorted(list(v)) for k, v in dimensions.items()}


def extract_indicator_names(mapping: list[dict[str, Any]]) -> list[str]:
    """Extract unique indicator names from the mapping."""
    names = set()
    for row in mapping:
        if row.get("include", True) and row.get("indicator_name"):
            names.add(row["indicator_name"])
    return sorted(list(names))


def generate_config_yml(
    metadata: dict[str, Any],
    dimensions: dict[str, list[str]],
) -> str:
    """Generate the config.yml content."""
    title_config: dict[str, Any] = {
        "title": metadata["title"],
    }
    if metadata.get("title_variant"):
        title_config["title_variant"] = metadata["title_variant"]

    config: dict[str, Any] = {
        "title": title_config,
        "default_selection": metadata["default_selection"],
        "topic_tags": metadata["topic_tags"],
        "dimensions": [],
        "views": [],
    }

    # Add dimensions
    for dim_name, choices in dimensions.items():
        dim_config = {
            "slug": dim_name,
            "name": dim_name.replace("_", " ").title(),
            "choices": [{"slug": choice, "name": choice.replace("_", " ").title()} for choice in choices],
        }
        config["dimensions"].append(dim_config)

    return ruamel_dump(config)


def generate_python_code(
    metadata: dict[str, Any],
    indicator_names: list[str],
    dimensions: dict[str, list[str]],
    common_config: dict[str, Any],
) -> str:
    """Generate the Python step file."""
    dim_list = list(dimensions.keys())
    dim_str = ", ".join(f'"{d}"' for d in dim_list) if dim_list else ""
    indicator_str = ", ".join(f'"{i}"' for i in indicator_names) if indicator_names else ""

    # Format common config
    common_config_lines = []
    for key, value in common_config.items():
        if isinstance(value, bool):
            common_config_lines.append(f'    "{key}": {value},')
        elif isinstance(value, list):
            common_config_lines.append(f'    "{key}": {value},')
        elif isinstance(value, (int, float)):
            common_config_lines.append(f'    "{key}": {value},')
        else:
            common_config_lines.append(f'    "{key}": "{value}",')

    common_config_str = "\n".join(common_config_lines) if common_config_lines else ""

    short_name = metadata["short_name"]

    code = f'''"""MDIM collection: {metadata["title"]}

Generated by MDIM Creator wizard.
"""

from etl.helpers import PathFinder

# Get paths and naming conventions for current step.
paths = PathFinder(__file__)


COMMON_CONFIG = {{
{common_config_str}
}}


def run() -> None:
    # Load default collection config
    config = paths.load_collection_config()

    # Load grapher dataset
    ds = paths.load_dataset("{short_name}")
    tb = ds.read("{short_name}", load_data=False)

    # Create collection
    c = paths.create_collection(
        config=config,
        tb=tb,
        indicator_names=[{indicator_str}],
        dimensions=[{dim_str}],
        common_view_config=COMMON_CONFIG,
    )

    # Optional: Edit views programmatically
    # for view in c.views:
    #     pass

    # Save collection
    c.save()
'''
    return code


def render() -> None:
    """Render the preview and generate stage."""
    st.subheader(":material/preview: Preview & Generate")

    st.markdown(
        """
        Review the configuration and generate your MDIM files.
        You can customize common view settings before generating.
        """
    )

    metadata = st.session_state.get("mdim_metadata", {})
    mapping = st.session_state.get("mdim_dimension_mapping", [])

    if not metadata or not mapping:
        st.error("Missing data. Please complete the previous steps.")
        return

    # Extract dimensions and indicators
    dimensions = extract_dimensions_from_mapping(mapping)
    indicator_names = extract_indicator_names(mapping)

    # Summary section
    st.markdown("### Summary")

    col1, col2, col3, col4 = st.columns(4)
    with col1:
        st.metric("Indicators", len(indicator_names))
    with col2:
        st.metric("Dimensions", len(dimensions))
    with col3:
        # Calculate views
        if dimensions:
            n_views = 1
            for choices in dimensions.values():
                n_views *= len(choices)
            n_views *= len(indicator_names)
        else:
            n_views = len(indicator_names)
        st.metric("Views", n_views)
    with col4:
        st.metric("Topic Tags", len(metadata.get("topic_tags", [])))

    # Dimension breakdown
    if dimensions:
        st.markdown("**Dimensions:**")
        for dim, choices in dimensions.items():
            st.markdown(f"- **{dim}**: {', '.join(choices)} ({len(choices)} choices)")

    # Common view configuration
    st.markdown("### Common View Configuration")

    col1, col2 = st.columns(2)

    with col1:
        chart_types = st.multiselect(
            "Chart types",
            options=CHART_TYPES,
            default=st.session_state.get("mdim_common_config", {}).get("chartTypes", ["LineChart"]),
            help="Chart types to include in the view selector",
        )

        has_map_tab = st.checkbox(
            "Include map tab",
            value=st.session_state.get("mdim_common_config", {}).get("hasMapTab", True),
            help="Whether to show a map tab for geographic data",
        )

    with col2:
        y_axis_min = st.number_input(
            "Y-axis minimum (optional)",
            value=st.session_state.get("mdim_common_config", {}).get("yAxisMin", 0),
            help="Minimum value for Y-axis (0 for auto)",
        )

        default_tab = st.selectbox(
            "Default tab",
            options=["chart", "map", "table"],
            index=["chart", "map", "table"].index(st.session_state.get("mdim_common_config", {}).get("tab", "chart")),
            help="Default tab to show when MDIM loads",
        )

    # Build common config
    common_config = {
        "chartTypes": chart_types,
        "hasMapTab": has_map_tab,
        "tab": default_tab,
    }
    if y_axis_min != 0:
        common_config["yAxis"] = {"min": y_axis_min}

    st.session_state.mdim_common_config = common_config

    # DAG configuration
    st.markdown("### DAG Integration")

    sorted_dag = sorted(
        dag_files,
        key=lambda file_name: fuzz.ratio(file_name.replace(".yml", ""), metadata.get("namespace", "")),
        reverse=True,
    )
    sorted_dag = [dag_not_add_option] + sorted_dag

    # Default selection
    if sorted_dag[1].replace(".yml", "") == metadata.get("namespace", ""):
        default_idx = 1
    else:
        default_idx = 0

    dag_file = st.selectbox(
        "Add to DAG",
        options=sorted_dag,
        index=default_idx,
        help="Select a DAG file to add this step to, or skip DAG integration.",
    )

    add_to_dag = dag_file != dag_not_add_option

    # Preview generated files
    st.markdown("### Preview Generated Files")

    # Generate content
    config_content = generate_config_yml(metadata, dimensions)
    python_content = generate_python_code(metadata, indicator_names, dimensions, common_config)

    # File paths
    target_dir = STEP_DIR / "export" / "multidim" / metadata["namespace"] / metadata["version"]
    config_path = target_dir / f"{metadata['short_name']}.config.yml"
    python_path = target_dir / f"{metadata['short_name']}.py"

    # Preview config.yml
    with st.expander(f"**{metadata['short_name']}.config.yml**", expanded=False):
        st.code(config_content, language="yaml")

    # Preview Python file
    with st.expander(f"**{metadata['short_name']}.py**", expanded=False):
        st.code(python_content, language="python")

    # DAG preview
    if add_to_dag:
        step_uri = f"export://multidim/{metadata['namespace']}/{metadata['version']}/{metadata['short_name']}"
        dag_entry = {
            step_uri: [f"data://grapher/{metadata['namespace']}/{metadata['version']}/{metadata['short_name']}"]
        }
        with st.expander(f"**DAG entry** ({dag_file})", expanded=False):
            st.code(ruamel_dump({"steps": dag_entry}), language="yaml")

    # Generate button
    st.markdown("### Generate Files")

    st.markdown(f"Files will be created at: `{target_dir}/`")

    col1, col2, col3 = st.columns([1, 1, 1])

    with col1:
        if st.button("Generate Files", type="primary", use_container_width=True):
            try:
                # Create directory
                target_dir.mkdir(parents=True, exist_ok=True)

                # Write config.yml
                with open(config_path, "w") as f:
                    f.write(config_content)

                # Write Python file
                with open(python_path, "w") as f:
                    f.write(python_content)

                # Add to DAG
                if add_to_dag:
                    step_uri = (
                        f"export://multidim/{metadata['namespace']}/{metadata['version']}/{metadata['short_name']}"
                    )
                    dag_entry = {
                        step_uri: [
                            f"data://grapher/{metadata['namespace']}/{metadata['version']}/{metadata['short_name']}"
                        ]
                    }
                    dag_path = DAG_DIR / dag_file
                    write_to_dag_file(
                        dag_file=dag_path,
                        dag_part=dag_entry,
                        comments={step_uri: f"\n#\n# {metadata['title']}\n#"},
                    )

                st.session_state.mdim_generated = True
                st.success("Files generated successfully!")

                # Show next steps
                st.markdown("### Next Steps")
                st.markdown(f"""
                1. Review the generated files:
                   - `{config_path}`
                   - `{python_path}`

                2. Run the ETL step:
                   ```bash
                   .venv/bin/etlr export://multidim/{metadata['namespace']}/{metadata['version']}/{metadata['short_name']} --private
                   ```

                3. Check the MDIM on staging

                4. Commit and create a PR
                """)

            except Exception as e:
                st.error(f"Error generating files: {e}")

    with col2:
        if st.button("Copy Python Code", use_container_width=True):
            st.code(python_content, language="python")
            st.info("Code displayed above. Copy it manually.")

    with col3:
        if st.button("Copy Config YAML", use_container_width=True):
            st.code(config_content, language="yaml")
            st.info("Config displayed above. Copy it manually.")
